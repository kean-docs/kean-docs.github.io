{"metadata":{"modules":[{"name":"Nuke"}],"role":"article","roleHeading":"Article","title":"Combine"},"kind":"article","sections":[],"abstract":[{"type":"text","text":"Learn how to use Combine publishers to improve image loading performance in your apps."}],"seeAlsoSections":[{"generated":true,"title":"Performance","identifiers":["doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/performance-guide","doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/prefetching","doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/caching","doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePrefetcher"]}],"hierarchy":{"paths":[["doc:\/\/com.github.kean.nuke\/documentation\/Nuke"]]},"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"overview"},{"inlineContent":[{"type":"text","text":"The publisher created using "},{"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline\/imagePublisher(with:)-3pzm6","isActive":true},{"type":"text","text":" method starts a new "},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageTask","type":"reference","isActive":true},{"text":" when a subscriber is added and delivers the results to the subscriber. If the requested image is available in the memory cache, the value is delivered immediately. When the subscription is canceled, the task also gets canceled.","type":"text"}],"type":"paragraph"},{"name":"Note","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you need to support earlier iOS versions, check out "},{"type":"reference","identifier":"https:\/\/github.com\/kean\/RxNuke","isActive":true},{"type":"text","text":"."}]}]},{"text":"Image Publisher","type":"heading","level":2,"anchor":"Image-Publisher"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To create a publisher, use "},{"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline\/imagePublisher(with:)-3pzm6","isActive":true},{"type":"text","text":" method from "},{"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline","isActive":true},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"A basic example where we load an image and display the result on success:"}],"type":"paragraph"},{"syntax":"swift","code":["cancellable = pipeline.imagePublisher(with: url)","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { imageView.image = $0.image })"],"type":"codeListing"},{"type":"heading","text":"Displaying Images","anchor":"Displaying-Images","level":2},{"inlineContent":[{"type":"text","text":"So you created a custom publisher by combining a couple of operators, how do you use it to display the image? NukeUI module provides a simple way to display the resulting image."}],"type":"paragraph"},{"type":"codeListing","code":["let image = FetchImage()","let publisher = pipeline.imagePublisher(with: \"https:\/\/example.com\/image.jpeg\")","image.load(publisher)"],"syntax":"swift"},{"anchor":"Use-Cases","text":"Use Cases","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"There are many scenarios in which you can find Combine useful. Here are some of them.","type":"text"}]},{"type":"heading","text":"Low Resolution to High","level":3,"anchor":"Low-Resolution-to-High"},{"inlineContent":[{"text":"Let’s say you want to show a user a high-resolution image that takes a while to loads. You can show a spinner while the high-resolution image is downloaded, but you can improve the user experience by quickly downloading and displaying a thumbnail.","type":"text"}],"type":"paragraph"},{"content":[{"inlineContent":[{"text":"As an alternative, Nuke also supports progressive JPEG. It is enabled by default.","type":"text"}],"type":"paragraph"}],"name":"Note","type":"aside","style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can implement it using "},{"type":"codeVoice","code":"append"},{"text":" operator. This operator results in a serial execution. It starts a thumbnail request, waits until it finishes, and only then starts a request for a high-resolution image.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let lowResImage = pipeline.imagePublisher(with: lowResUrl).orEmpty","let highResImage = pipeline.imagePublisher(with: highResUrl).orEmpty","","cancellable = lowResImage.append(highResImage)","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { imageView.image = $0.image })"]},{"name":"Note","content":[{"inlineContent":[{"type":"codeVoice","code":"orEmpty"},{"text":" is a custom property which catches the errors and immediately completes the publishes instead.","type":"text"}],"type":"paragraph"}],"style":"note","type":"aside"},{"syntax":"swift","code":["public extension Publisher {","    var orEmpty: AnyPublisher<Output, Never> {","        catch { _ in Empty<Output, Never>() }.eraseToAnyPublisher()","    }","}"],"type":"codeListing"},{"type":"heading","level":3,"anchor":"Load-the-First-Available","text":"Load the First Available"},{"inlineContent":[{"text":"Let’s say you have multiple URLs for the same image. For example, you uploaded the image from the camera to the server; you have the image stored locally. When you display this image, it would be beneficial to first load the local URL, and if that fails, try to download from the network.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This use case is very similar to going from low to high resolution, except for the addition of the "},{"type":"codeVoice","code":"first()"},{"text":" operator that stops the execution when the first value is received.","type":"text"}]},{"type":"codeListing","code":["let localImage = pipeline.imagePublisher(with: localUrl).orEmpty","let networkImage = pipeline.imagePublisher(with: networkUrl).orEmpty","","cancellable = localImage.append(networkImage)","    .first()","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { imageView.image = $0.image })"],"syntax":"swift"},{"level":3,"anchor":"Load-Multiple-Images","type":"heading","text":"Load Multiple Images"},{"inlineContent":[{"type":"text","text":"Let’s say you want to load two icons for a button, one icon for a "},{"type":"codeVoice","code":".normal"},{"text":" state, and one for a ","type":"text"},{"type":"codeVoice","code":".selected"},{"text":" state. You want to update the button, only when both icons are fully loaded. This can be achieved using a ","type":"text"},{"code":"combine","type":"codeVoice"},{"text":" operator.","type":"text"}],"type":"paragraph"},{"code":["let iconImage = pipeline.imagePublisher(with: iconUrl)","let iconSelectedImage = pipeline.imagePublisher(with: iconSelectedUrl)","","cancellable = iconImage.combineLatest(iconSelectedImage)","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { icon, iconSelected in","            button.isHidden = false","            button.setImage(icon.image, for: .normal)","            button.setImage(iconSelected.image, for: .selected)","         })"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Notice there is no "},{"type":"codeVoice","code":"orEmpty"},{"type":"text","text":" in this example since we want both requests to succeed."}],"type":"paragraph"},{"level":3,"text":"Validate Stale Image","type":"heading","anchor":"Validate-Stale-Image"},{"inlineContent":[{"type":"text","text":"Let’s say you want to show the user a stale image stored in disk cache ("},{"type":"codeVoice","code":"Foundation.URLCache"},{"text":") while you go to the server to validate if the image is still fresh. It can be implemented using the same ","type":"text"},{"type":"codeVoice","code":"append"},{"text":" operator that we covered previously.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let cacheRequest = URLRequest(url: url, cachePolicy: .returnCacheDataDontLoad)","let networkRequest = URLRequest(url: url, cachePolicy: .useProtocolCachePolicy)","","let cachedImage = pipeline.imagePublisher(with: ImageRequest(urlRequest: cacheRequest)).orEmpty","let networkImage = pipeline.imagePublisher(with: ImageRequest(urlRequest: networkRequest)).orEmpty","","cancellable = cachedImage.append(networkImage)","    .sink(receiveCompletion: { _ in \/* Ignore errors *\/ },","          receiveValue: { imageView.image = $0.image })"]},{"type":"heading","anchor":"Low-Data-Mode","level":3,"text":"Low Data Mode"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Starting with iOS 13, the iOS users can enable “Low Data Mode” in system settings. One of the ways the apps can handle it is to use resources that take less network bandwidth. Combine makes it easy to implement."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Create the original image request and prevent it from going through","\/\/ when \"Low Data Mode\" is enabled in the iOS settings.","var urlRequest = URLRequest(url: URL(string: \"https:\/\/example.com\/high-quality.jpeg\")!)","urlRequest.allowsConstrainedNetworkAccess = false","let request = ImageRequest(urlRequest: urlRequest)","","\/\/ Catch the \"constrained\" network error and provide a fallback resource","\/\/ that uses less network bandwidth.","let image = pipeline.imagePublisher(with: request).tryCatch { error -> ImagePublisher in","    guard (error.dataLoadingError as? URLError)?.networkUnavailableReason == .constrained else {","        throw error","    }","    return pipeline.imagePublisher(with: URL(string: \"https:\/\/example.com\/low-quality.jpeg\"))","}","","cancellable = image.sink(receiveCompletion: { result in","    \/\/ Handle error","}, receiveValue: {","    imageView.image = $0.image","})"]},{"type":"aside","style":"tip","content":[{"inlineContent":[{"type":"text","text":"Learn more about Low Data Mode in "},{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2019\/712\/","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"}],"name":"Tip"}]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/nuke\/combine"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/combine"},"references":{"https://github.com/kean/RxNuke":{"title":"RxNuke","type":"link","titleInlineContent":[{"type":"text","text":"RxNuke"}],"url":"https:\/\/github.com\/kean\/RxNuke","identifier":"https:\/\/github.com\/kean\/RxNuke"},"doc://com.github.kean.nuke/documentation/Nuke/ImagePipeline/imagePublisher(with:)-3pzm6":{"fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"imagePublisher"},{"text":"(","kind":"text"},{"text":"with","kind":"externalParam"},{"kind":"text","text":": "},{"text":"ImageRequest","kind":"typeIdentifier","preciseIdentifier":"s:4Nuke12ImageRequestV"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:7Combine12AnyPublisherV","kind":"typeIdentifier","text":"AnyPublisher"},{"kind":"text","text":"<"},{"text":"ImageResponse","kind":"typeIdentifier","preciseIdentifier":"s:4Nuke13ImageResponseV"},{"text":", ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:4Nuke13ImagePipelineC5ErrorO","text":"Error"},{"text":">","kind":"text"}],"abstract":[{"type":"text","text":"Returns a publisher which starts a new "},{"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageTask","isActive":true},{"text":" when a subscriber is added.","type":"text"}],"role":"symbol","kind":"symbol","url":"\/documentation\/nuke\/imagepipeline\/imagepublisher(with:)-3pzm6","type":"topic","title":"imagePublisher(with:)","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline\/imagePublisher(with:)-3pzm6"},"doc://com.github.kean.nuke/documentation/Nuke":{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke","url":"\/documentation\/nuke","kind":"symbol","role":"collection","type":"topic","title":"Nuke","abstract":[{"text":"A powerful image loading system for Apple platforms.","type":"text"}]},"doc://com.github.kean.nuke/documentation/Nuke/performance-guide":{"title":"Performance Guide","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/performance-guide","kind":"article","abstract":[{"type":"text","text":"Learn about the performance features in Nuke and how to make the most of them."}],"type":"topic","role":"article","url":"\/documentation\/nuke\/performance-guide"},"doc://com.github.kean.nuke/documentation/Nuke/ImagePrefetcher":{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePrefetcher","type":"topic","kind":"symbol","url":"\/documentation\/nuke\/imageprefetcher","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"ImagePrefetcher","kind":"identifier"}],"role":"symbol","abstract":[{"type":"text","text":"Prefetches and caches images to eliminate delays when requesting the same"},{"type":"text","text":" "},{"type":"text","text":"images later."}],"navigatorTitle":[{"kind":"identifier","text":"ImagePrefetcher"}],"title":"ImagePrefetcher"},"doc://com.github.kean.nuke/documentation/Nuke/ImageTask":{"abstract":[{"text":"A task performed by the ","type":"text"},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline","isActive":true,"type":"reference"},{"type":"text","text":"."}],"url":"\/documentation\/nuke\/imagetask","role":"symbol","type":"topic","kind":"symbol","navigatorTitle":[{"text":"ImageTask","kind":"identifier"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ImageTask"}],"title":"ImageTask","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageTask"},"doc://com.github.kean.nuke/documentation/Nuke/ImagePipeline":{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline","url":"\/documentation\/nuke\/imagepipeline","kind":"symbol","navigatorTitle":[{"text":"ImagePipeline","kind":"identifier"}],"role":"symbol","type":"topic","title":"ImagePipeline","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"text":"ImagePipeline","kind":"identifier"}],"abstract":[{"text":"The pipeline downloads and caches images, and prepares them for display.","type":"text"}]},"doc://com.github.kean.nuke/documentation/Nuke/caching":{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/caching","abstract":[{"type":"text","text":"Learn about cache layers in Nuke and how to configure them."}],"kind":"article","role":"collectionGroup","title":"Caching","type":"topic","url":"\/documentation\/nuke\/caching"},"doc://com.github.kean.nuke/documentation/Nuke/prefetching":{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/prefetching","title":"Prefetching","kind":"article","abstract":[{"type":"text","text":"Learn how to prefetch images to improve user experience."}],"type":"topic","role":"article","url":"\/documentation\/nuke\/prefetching"},"https://developer.apple.com/videos/play/wwdc2019/712/":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2019\/712\/","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2019\/712\/","type":"link","title":"WWDC2019: Advances in Networking, Part 1","titleInlineContent":[{"type":"text","text":"WWDC2019: Advances in Networking, Part 1"}]}}}